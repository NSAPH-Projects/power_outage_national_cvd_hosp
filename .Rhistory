"fips",
"city_name",
"utility_name")]
# join the power outage data back to that date backbone, rolling to fill in
pous_dat_chunk <-
pous_dat_chunk[all_dates_in_data, on = .(clean_state_name,
clean_county_name,
city_name,
utility_name,
fips,
date), roll = TRUE]
# replace -99 marker with NA
pous_dat_chunk[, customers_out_api_on :=
ifelse(customers_out == -99, NA, customers_out)]
# need to join to original backbone now to get all time we're supposed to have # flag - slow
pous_dat_chunk <- pous_dat_chunk[city_utility_time_series, on = c(
'clean_state_name',
"clean_county_name",
"fips",
"city_name",
"utility_name",
"date"
)]
pous_dat_chunk[, year := lubridate::year(date)]
ii <- pous_dat_chunk %>% group_by(city_utility_name_id) %>% summarize(n = sum(!is.na(customers_out_api_on)))
View(ii)
pacman::p_load(tidyverse, here, lubridate, zoo, data.table, fst)
renv::status()
?renv::status
renv::snapshot()
# Join customer estimates from EIA to the live customer estimate data,
# calculate person-coverage, and then eliminate counties with insufficient
# coverage.
# Libraries ---------------------------------------------------------------
pacman::p_load(tidyverse, here, lubridate, zoo, data.table, fst)
my.max <- function(x)
ifelse(!all(is.na(x)), max(x, na.rm = T), NA)
person_coverage_threshold <- 0.5
# Do ----------------------------------------------------------------------
# read in EIA estimates downscaled to the county level in an earlier script
eia_estimates <-
read_rds(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"downscaled_county_customer_estimates.RDS"
)
) %>%
select(year, five_digit_fips, downscaled_county_estimate)
# read in counties hourly data
counties <-
list.files(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"hourly_county"
),
pattern = "*.fst",
full.names = TRUE
)
hourly <- lapply(counties, read_fst)
hourly <- rbindlist(hourly)
# reduce to just customer estimates
pous_based_estimates <- hourly %>%
select(
clean_state_name,
clean_county_name,
fips,
customers_served_hourly,
county_person_time_missing
) %>% distinct()
# read in EIA estimates downscaled to the county level in an earlier script
eia_estimates <-
read_rds(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"downscaled_county_customer_estimates.RDS"
)
) %>%
select(year, five_digit_fips, downscaled_county_estimate)
# read in counties hourly data
counties <-
list.files(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"hourly_county"
),
pattern = "*.fst",
full.names = TRUE
)
hourly <- lapply(counties, read_fst)
hourly <- rbindlist(hourly)
# reduce to just customer estimates
pous_based_estimates <- hourly %>%
select(
clean_state_name,
clean_county_name,
five_digit_fips,
customers_served_hourly,
county_person_time_missing
) %>% distinct()
glimpse(pous_based_estimates)
View(pous_based_estimates)
# reduce to just customer estimates
pous_based_estimates <- hourly %>%
select(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
customers_served_hourly,
county_person_time_missing
) %>% distinct()
View(pous_based_estimates)
colnames(eia_estimates)
pous_based_estimates <- pous_based_estimates %>% left_join(eia_estimates)
View(pous_based_estimates)
# mark when the pous data looks like it has an error
pous_based_estimates <- pous_based_estimates %>%
mutate(
too_big = case_when(
customers_served_hourly > downscaled_county_estimate ~ customers_served_hourly /
downscaled_county_estimate,
T ~ 0
)
)
# select the appropriate columns
pous_based_estimates <- pous_based_estimates[, .(
clean_state_name,
clean_county_name,
fips,
year,
hour,
customers_served_hourly,
county_person_time_missing,
downscaled_county_estimate,
too_big
)]
# select the appropriate columns
pous_based_estimates <- pous_based_estimates[, .(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
hour,
customers_served_hourly,
county_person_time_missing,
downscaled_county_estimate,
too_big
)]
# going to use the POUS estimates when they are less than twice the eia estimate
pous_based_estimates <- pous_based_estimates %>%
mutate(
customers_served_estimate_to_use = case_when(
too_big < 2 ~ customers_served_hourly,
T ~ downscaled_county_estimate
)
)
# exclude low person coverage - should update this to be person-time coverage,
# and as an indicator; first collect cols
estimate_missing <-
pous_based_estimates %>%
select(
clean_state_name,
clean_county_name,
fips,
year,
customers_served_hourly,
county_person_time_missing,
downscaled_county_estimate,
customers_served_estimate_to_use
) %>%
distinct()
# exclude low person coverage - should update this to be person-time coverage,
# and as an indicator; first collect cols
estimate_missing <-
pous_based_estimates %>%
select(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
customers_served_hourly,
county_person_time_missing,
downscaled_county_estimate,
customers_served_estimate_to_use
) %>%
distinct()
# do calc
estimate_missing <-
estimate_missing %>%
mutate(
expected_hrs = downscaled_county_estimate * 365 * 24,
# hrs that should be in the dataset
hrs_served = customers_served_estimate_to_use * 365 * 24,
# person-hrs that should be in the dataset
hrs_actually_served = hrs_served - (county_person_time_missing /
6),
# subtract missing hrs
p_present = hrs_actually_served / expected_hrs
) # percentage served out of total hrs
hourly <- hourly %>% left_join(estimate_missing)
View(hourly)
View(estimate_missing)
hourly <- hourly %>% filter(p_present > 0.5)
# Join customer estimates from EIA to the live customer estimate data,
# calculate person-coverage, and then eliminate counties with insufficient
# coverage.
# Libraries ---------------------------------------------------------------
pacman::p_load(tidyverse, here, lubridate, zoo, data.table, fst)
my.max <- function(x)
ifelse(!all(is.na(x)), max(x, na.rm = T), NA)
person_coverage_threshold <- 0.5
# Do ----------------------------------------------------------------------
# read in EIA estimates downscaled to the county level in an earlier script
eia_estimates <-
read_rds(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"downscaled_county_customer_estimates.RDS"
)
) %>%
select(year, five_digit_fips, downscaled_county_estimate)
# read in counties hourly data
counties <-
list.files(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"hourly_county"
),
pattern = "*.fst",
full.names = TRUE
)
hourly <- lapply(counties, read_fst)
hourly <- rbindlist(hourly)
# reduce to just customer estimates
pous_based_estimates <- hourly %>%
select(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
customers_served_hourly,
county_person_time_missing
) %>% distinct()
# Do ----------------------------------------------------------------------
pous_based_estimates <- pous_based_estimates %>% left_join(eia_estimates)
# mark when the pous data looks like it has an error
pous_based_estimates <- pous_based_estimates %>%
mutate(
too_big = case_when(
customers_served_hourly > downscaled_county_estimate ~ customers_served_hourly /
downscaled_county_estimate,
T ~ 0
)
)
# select the appropriate columns
pous_based_estimates <- pous_based_estimates[, .(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
hour,
customers_served_hourly,
county_person_time_missing,
downscaled_county_estimate,
too_big
)]
# going to use the POUS estimates when they are less than twice the eia estimate
pous_based_estimates <- pous_based_estimates %>%
mutate(
customers_served_estimate_to_use = case_when(
too_big < 2 ~ customers_served_hourly,
T ~ downscaled_county_estimate
)
)
# exclude low person coverage - should update this to be person-time coverage,
# and as an indicator; first collect cols
estimate_missing <-
pous_based_estimates %>%
select(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
customers_served_hourly,
county_person_time_missing,
downscaled_county_estimate,
customers_served_estimate_to_use
) %>%
distinct()
# do calc
estimate_missing <-
estimate_missing %>%
mutate(
expected_hrs = downscaled_county_estimate * 365 * 24,
# hrs that should be in the dataset
hrs_served = customers_served_estimate_to_use * 365 * 24,
# person-hrs that should be in the dataset
hrs_actually_served = hrs_served - (county_person_time_missing /
6),
# subtract missing hrs
p_present = hrs_actually_served / expected_hrs
) # percentage served out of total hrs
hourly <- hourly %>% left_join(estimate_missing)
dim(hourly)
length(unique(hourly$five_digit_fips))
hourly <- hourly %>% filter(p_present > 0.5)
length(unique(hourly$five_digit_fips))
# Join customer estimates from EIA to the live customer estimate data,
# calculate person-coverage, and then eliminate counties with insufficient
# coverage.
# Author: Heather
# Last updated: Oct 4th, 2024
# Libraries ---------------------------------------------------------------
pacman::p_load(tidyverse, here, lubridate, zoo, data.table, fst)
my.max <- function(x)
ifelse(!all(is.na(x)), max(x, na.rm = T), NA)
person_coverage_threshold <- 0.5
# Do ----------------------------------------------------------------------
# read in EIA estimates downscaled to the county level in an earlier script
eia_estimates <-
read_rds(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"downscaled_county_customer_estimates.RDS"
)
) %>%
select(year, five_digit_fips, downscaled_county_estimate)
# read in counties hourly data
counties <-
list.files(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"hourly_county"
),
pattern = "*.fst",
full.names = TRUE
)
hourly <- lapply(counties, read_fst)
hourly <- rbindlist(hourly)
# reduce to just customer estimates
pous_based_estimates <- hourly %>%
select(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
customers_served_hourly,
county_person_time_missing
) %>% distinct()
pous_based_estimates <- pous_based_estimates %>% left_join(eia_estimates)
View(pous_based_estimates)
# read in EIA estimates downscaled to the county level in an earlier script
eia_estimates <-
read_rds(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"downscaled_county_customer_estimates.RDS"
)
) %>%
select(year, five_digit_fips, downscaled_county_estimate)
View(eia_estimates)
# This script uses estimates from EIA of the number of electrical customers in
# a state, and census estimates of the number of households and establishments
# in counties within states, to get estimates of the number of electrical
# customers in each county in each state. Each county is allocated customers
# from EIA totals based on the percentage of households and establishments in
# the state that are in that county.
# Author: Heather
# Last date updated: Oct 2nd, 2024
# Libraries ---------------------------------------------------------------
pacman::p_load(tidyverse, here)
# Read --------------------------------------------------------------------
# customer estimates
census_cust_estimates <-
read_rds(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"county_level_census_cust_estimates.RDS"
))
# eia totals
eia_totals <-
read_rds(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"eia_state_total_customers_by_year.RDS"
)
)
View(census_cust_estimates)
source("/Volumes/squirrel-utopia 2/power_outage_national_cvd_hosp/code/data_prep/power_outage_exposure_data_prep/a02_get_county_census_cust_est.R")
source("/Volumes/squirrel-utopia 2/power_outage_national_cvd_hosp/code/data_prep/power_outage_exposure_data_prep/a03_county_customer_census_estimates.R")
# Join customer estimates from EIA to the live customer estimate data,
# calculate person-coverage, and then eliminate counties with insufficient
# coverage.
# Author: Heather
# Last updated: Oct 4th, 2024
# Libraries ---------------------------------------------------------------
pacman::p_load(tidyverse, here, lubridate, zoo, data.table, fst)
my.max <- function(x)
ifelse(!all(is.na(x)), max(x, na.rm = T), NA)
person_coverage_threshold <- 0.5
# Do ----------------------------------------------------------------------
# read in EIA estimates downscaled to the county level in an earlier script
eia_estimates <-
read_rds(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"downscaled_county_customer_estimates.RDS"
)
) %>%
select(year, five_digit_fips, downscaled_county_estimate)
# read in counties hourly data
counties <-
list.files(
here(
"data",
"power_outage_exposure_data_cleaning_output",
"hourly_county"
),
pattern = "*.fst",
full.names = TRUE
)
View(eia_estimates)
hourly <- lapply(counties, read_fst)
hourly <- rbindlist(hourly)
# reduce to just customer estimates
pous_based_estimates <- hourly %>%
select(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
customers_served_hourly,
county_person_time_missing
) %>% distinct()
pous_based_estimates <- pous_based_estimates %>% left_join(eia_estimates)
# mark when the pous data looks like it has an error
pous_based_estimates <- pous_based_estimates %>%
mutate(
too_big = case_when(
customers_served_hourly > downscaled_county_estimate ~ customers_served_hourly /
downscaled_county_estimate,
T ~ 0
)
)
# select the appropriate columns
pous_based_estimates <- pous_based_estimates[, .(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
hour,
customers_served_hourly,
county_person_time_missing,
downscaled_county_estimate,
too_big
)]
# going to use the POUS estimates when they are less than twice the eia estimate
pous_based_estimates <- pous_based_estimates %>%
mutate(
customers_served_estimate_to_use = case_when(
too_big < 2 ~ customers_served_hourly,
T ~ downscaled_county_estimate
)
)
# exclude low person coverage - should update this to be person-time coverage,
# and as an indicator; first collect cols
estimate_missing <-
pous_based_estimates %>%
select(
clean_state_name,
clean_county_name,
five_digit_fips,
year,
customers_served_hourly,
county_person_time_missing,
downscaled_county_estimate,
customers_served_estimate_to_use
) %>%
distinct()
# do calc
estimate_missing <-
estimate_missing %>%
mutate(
expected_hrs = downscaled_county_estimate * 365 * 24,
# hrs that should be in the dataset
hrs_served = customers_served_estimate_to_use * 365 * 24,
# person-hrs that should be in the dataset
hrs_actually_served = hrs_served - (county_person_time_missing /
6),
# subtract missing hrs
p_present = hrs_actually_served / expected_hrs
) # percentage served out of total hrs
hourly <- hourly %>% left_join(estimate_missing)
glimpse(hourly)
length(unique(hourly$five_digit_fips))
hourly <- hourly %>% filter(p_present > 0.5)
length(unique(hourly$five_digit_fips))
unique(hourly$year)
View(estimate_missing)
source("/Volumes/squirrel-utopia 2/power_outage_national_cvd_hosp/code/data_prep/power_outage_exposure_data_prep/b03_attach_denoms.R")
